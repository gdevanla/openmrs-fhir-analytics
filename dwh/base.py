# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""This is the main higher level library to query FHIR resources.

The public interface of this library is intended to be independent of the actual
query engine, e.g., Spark, SQL/BigQuery, etc. The only exception is a single
function that defines the source of the data.
"""

# See https://stackoverflow.com/questions/33533148 why this is needed.
from __future__ import annotations
from enum import Enum
from typing import List, Any, Type, Optional
import pandas
from pyspark import SparkConf
from pyspark.sql import SparkSession, DataFrame

import pyspark.sql.types as T
import common

class _ObsConstraints():
  """ An abstraction layer around observation constraints for a single code.

  It is assumed that the conditions generated by the `sql` function is applied
  on an already flattened observation view.
  """

  def __init__(self, code: str, values: List[str] = None, value_sys: str = None,
      min_value: float = None, max_value: float = None,
      min_time: str = None, max_time: str = None) -> None:
    self._code = code
    self._sys_str = '="{}"'.format(value_sys) if value_sys else 'IS NULL'
    self._values = values
    self._min_time = min_time
    self._max_time = max_time
    self._min_value = min_value
    self._max_value = max_value

  @staticmethod
  def time_constraint(min_time: str = None, max_time: str = None):
    if not min_time and not max_time:
      return 'TRUE'
    cl = []
    if min_time:
      cl.append('dateTime >= "{}"'.format(min_time))
    if max_time:
      cl.append('dateTime <= "{}"'.format(max_time))
    return ' AND '.join(cl)

  def sql(self) -> str:
    """This creates a constraint string with WHERE syntax in SQL.

    All of the observation constraints specified by this instance are joined
    together into an `AND` clause.
    """
    cl = [self.time_constraint(self._min_time, self._max_time)]
    cl.append('coding.code="{}"'.format(self._code))
    # We don't need to filter coding.system as it is already done in flattening.
    if self._values:
      codes_str = ','.join(['"{}"'.format(v) for v in self._values])
      cl.append('value.codeableConcept.coding IN ({})'.format(codes_str))
      cl.append('value.codeableConcept.system {}'.format(self._sys_str))
    elif self._min_value or self._max_value:
      if self._min_value:
        cl.append(' value.quantity.value >= {} '.format(self._min_value))
      if self._max_value:
        cl.append(' value.quantity.value <= {} '.format(self._max_value))
    return '({})'.format(' AND '.join(cl))


class _EncounterContraints():
  """ An abstraction layer around all encounter constraints.

  It is assumed that the conditions generated by the `sql` function is applied
  on an already flattened encounter view.
  """

  def __init__(self, locationId: List[str] = None,
      typeSystem: str = None, typeCode: List[str] = None):
    self._location_id = locationId
    self._type_system = typeSystem
    self._type_code = typeCode

  def has_location(self) -> bool:
    return self._location_id != None

  def has_type(self) -> bool:
    return (self._type_code != None) or (self._type_system != None)

  def sql(self) -> str:
    """This creates a constraint string with WHERE syntax in SQL."""
    loc_str = 'TRUE'
    if self._location_id:
      temp_str = ','.join(['"{}"'.format(v) for v in self._location_id])
      loc_str = 'locationId IN ({})'.format(temp_str)
    type_code_str = 'TRUE'
    if self._type_code:
      temp_str = ','.join(['"{}"'.format(v) for v in self._type_code])
      #type_code_str = 'encTypeCode IN ({})'.format(temp_str)
      type_code_str = ' arrays_overlap(encTypeCode, array({})) '.format(temp_str)
    type_sys_str = 'TRUE'
    if self._type_system:
        type_sys_str = ' array_contains(encTypeSystem,  "{}") '.format(self._type_system)
    return '{} AND {} AND {}'.format(loc_str, type_code_str, type_sys_str)


# TODO add Patient filtering criteria to this query API.
class PatientQuery():
  """The main class for specifying a patient query.

  The expected usage flow is:
  - The user specifies where the data comes from and what query engine should
    be used, e.g., Parquet files with Spark, a SQL engine like BigQuery, or even
    a FHIR server/API (future).
  - Constraints are set, e.g., observation codes, values, date, etc.
  - The query is run on the underlying engine and a Pandas DataFrame is created.
  - The DataFrame is fetched or more manipulation is done on it by the library.
  """

  def __init__(
          self,
          code_system: str = None,
          encounter_constraints_class: Type[_EncounterContraints]=_EncounterContraints,
          obs_constraints_class: Type[_ObsConstraints]=_ObsConstraints):

    self._code_constraint = {}
    self._enc_constraint = encounter_constraints_class()
    self._include_all_codes = False
    self._all_codes_min_time = None
    self._all_codes_max_time = None
    self._code_system = code_system

    self._enc_constraints_class = encounter_constraints_class
    self._obs_constraints_class = obs_constraints_class

  def include_obs_in_value_and_time_range(self, code: str,
      min_val: float = None, max_val: float = None, min_time: str = None,
      max_time: str = None) -> PatientQuery:
    if code in self._code_constraint:
      raise ValueError('Duplicate constraints for code {}'.format(code))
    self._code_constraint[code] = self._obs_constraints_class(
        code, value_sys=self._code_system, min_value=min_val,
        max_value=max_val, min_time=min_time, max_time=max_time)
    return self

  def include_obs_values_in_time_range(self, code: str,
      values: List[str] = None, min_time: str = None,
      max_time: str = None) -> PatientQuery:
    if code in self._code_constraint:
      raise ValueError('Duplicate constraints for code {}'.format(code))
    self._code_constraint[code] = self._obs_constraints_class(
        code, values=values, value_sys=self._code_system, min_time=min_time,
        max_time=max_time)
    return self

  def include_all_other_codes(self, include: bool = True, min_time: str = None,
      max_time: str = None) -> PatientQuery:
    self._include_all_codes = include
    self._all_codes_min_time = min_time
    self._all_codes_max_time = max_time
    return self

  def encounter_constraints(self, locationId: List[str] = None,
      typeSystem: str = None, typeCode: List[str] = None):
    """Specifies constraints on encounters to be included.

    Note calling this erases previous encounter constraints. Any constraint
    that is None is ignored.

    Args:
      locationId: The list of locations that should be kept or None if there are
        no location constraints.
      typeSystem: An string representing the type system or None.
      typeCode: A list of encounter type codes that should be kept or None if
        there are no type constraints.
    """
    self._enc_constraint = self._enc_constraints_class(
        locationId, typeSystem, typeCode)

  def _all_obs_constraints(self) -> str:
    if not self._code_constraint:
      if self._include_all_codes:
        return 'TRUE'
      else:
        return 'FALSE'
    constraints_str = ' OR '.join(
        [self._code_constraint[code].sql() for code in self._code_constraint])
    if not self._include_all_codes:
      return '({})'.format(constraints_str)
    others_str = ' AND '.join(
        ['coding.code!="{}"'.format(code) for code in self._code_constraint] + [
            self._obs_constraints_class.time_constraint(self._all_codes_min_time,
                                            self._all_codes_max_time)])
    return '({} OR ({}))'.format(constraints_str, others_str)

  def all_constraints_sql(self) -> str:
    obs_str = self._all_obs_constraints()
    enc_str = '{}'.format(
        self._enc_constraint.sql()) if self._enc_constraint else 'TRUE'
    return '{} AND {}'.format(obs_str, enc_str)

  # TODO remove `base_url` parameter once issue #55 is fixed.
  def get_patient_obs_view(self, base_url: str) -> pandas.DataFrame:
    """Creates a patient * observation code aggregated view.

    For each patient and observation code, group all such observation and
    returns some aggregated values. Loads the data if that is necessary.

    Args:
      base_url: See issue #55!

    Returns:
      A Pandas DataFrame with the following columns:
        - `patientId` the patient for whom the aggregation is done
        - `birthDate` the patient's birth date
        - `gender` the patient's gender
        - `code` the code of the observation in the `code_system`
        - `num_obs` number of observations with above spec
        - `min_value` the minimum obs value in the specified period or `None` if
          this observation does not have a numeric value.
        - `max_value` the maximum obs value in the specified period or `None`
        - `min_date` the first time that an observation with the given code was
           observed in the specified period.
        - `max_date` ditto for last time
        - `first_value` the value corresponding to `min_date`
        - `last_value` the value corresponding to `max_date`
        - `first_value_code` the coded value corresponding to `min_date`
        - `last_value_code` the coded value corresponding to `max_date`
    """
    raise NotImplementedError('This should be implemented by sub-classes!')

  def get_patient_encounter_view(self, base_url: str,
      force_location_type_columns: bool = True) -> pandas.DataFrame:
    """Aggregates encounters for each patient based on location, type, etc.

    For each patient and encounter attributes (e.g., location, type, etc.) finds
    aggregate values. Loads the data if that is necessary.

    Args:
      base_url: See issue #55!
      force_location_type_columns: whehter to include location and type related
        columns regardless of the constraints. Note this can duplicate a single
        encounter to many rows if that row has multiple locations and types.

    Returns:
      A Pandas DataFrame with the following columns:
        - `patientId` the patient for whom the aggregation is done
        - `locationId` the location ID of where the encounters took place; this
          and the next one are provided only if there is a location constraint
          or `force_location_type_columns` is `True`.
        - `locationDisplay` the human readable name of the location
        - `encTypeSystem` the encounter type system this and the next one are
          provided only if there is a type constraint or
          `force_location_type_columns` is `True`.
        - `encTypeCode` the encounter type code
        - `numEncounters` number of encounters with that type and location
        - `firstDate` the first date such an encounter happened
        - `lastDate` the last date such an encounter happened
    """
    raise NotImplementedError('This should be implemented by sub-classes!')
